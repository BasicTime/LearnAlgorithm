## 第零章序
一切都是技术问题，和智商没关系，写不出来是缺乏练习。  
知道思路，多练习，总结代码块习惯
## 一些技巧
```java
//1
mid = (L+R)/2 => mid = L+((R-L)>>1);//计算中数
//2
swap(int [] arr,int idx1,int idx2){
    arr[idx1] = arr[idx1]^arr[idx2];
    arr[idx2] = arr[idx1]^arr[idx2];
    arr[idx1] = arr[idx1]^arr[idx2];
}
```


## 第一章节
时间复杂度为一个算法中，最差常数操作数的指标。  
额外空间复杂度，有限几个变量O(1),辅助数组空间O(n)
### 1.一个N长度有序数组a，一个M无序数组b，打印出b中不在a中的数？

>1）双重遍历  
O(M\*N)  
2）在a中通过二分查找b中的每个数  
O(M\*logN)  
3）先排序b，在通过外排比较的方式比较有序数据a和有序数据b'的数  
O(M\*logM)+O(M+N)  
tips：  
比较2）和3）时间复杂度问题，  
如果a很短，b很长，2）更优  
如果a很长，b很短，3）更优  

###2.冒泡排序  
> 每次比较前一个数和当前数，如果前一个数更大就交换，其他情况就往下走。  
说明：每次遍历都只排序好一个最大的数到当前循环体的末尾
如：  
第一次循环，0到length-1把最大值交换到length-1位置  
第二次循环，0到length-2把最大值交换到length-2位置  
第三次循环，0到length-3把最大值交换到length-3位置  
...  

### 3.选择排序
> 每次循环找出一个最小的数，做多做一次交换  
> 第一次循环，由0到length-1 找到最小值，记录下标，交换到0位置  
> 第二次循环，由1到length-1 找到最小值，记录下标，交换到1位置上  
> 第三次循环，由2到length-1 找到最小值，记录下标，交换到2位置上  
> ...  

### 4.插入排序
> 每次循环比较当前值和之前的数据列表中的值（下标由最大向前递减），
>如果当前值比较小，集合中的数就与后一个数交换

排序情况和数据状况有关时，按照最差的估计  
`最好情况`
有序的时候O(n)  
`最差情况`
逆序的时候O(n<sup>2</sup>)  
`平均情况`

### 4.小结
外层循环界定内层循环边界

### 5.递归的行为和递归的时间复杂度
进栈和出栈的过程  
递归都可以用非递归的方式修改，就是自己做进栈和出栈的过程  
递归行为的复杂度  
`估计递归时间复杂度的通式` 
T(N) = aT(n/b)+O(n<sup>d</sup>)  
n 样本量  
n/b 子过程的样本量  
a 多少个子过程  
O(n<sup>d</sup>)除去调用子过程外的时间复杂度  
当 b=2,a=2,d=0 => 2T(n/2)+O(1) 满足这个公式的直接按照通式计算时间复杂度   
T(N) = a*T(N/b) + O(N<sup>d</sup>)  
1) log(b,a) > d ->时间复杂度O(N<sup>log(b,a)</sup>)  
当a=b=2,d=0时，递归时间复杂度O(N)
2) log(b,a) = d ->时间复杂度O(N<sup>d</sup>*log(2,N))  
当a=b=2,d=1时，递归时间复杂度O(Nlog2<sup>N</sup>)
3) log(b,a) < d ->时间复杂度O(N<sup>d</sup>)  
当a=b=2,d=2时候,递归时间复杂度为O(N<sup>2</sup>)
### 6.用递归的方式查找数据组中最大值
> 递归使用分治思想

### 7.归并排序
时间复杂度O(N*logN),额外空间复杂度O(N)
1. 通过分治思想，把样本才分有2，进行左右一共2次的拆分进行排序
2. 把左右两个有序数组merge到一个help数组
3. 再help数组交换到原数组  

通过master公式计算分治思想的算法复杂度  
a=b=2,T(n) = 2(n/2)+O(n<sup>1</sup>)=> a=b=2 > d=1 => 时间复杂度为O(n*log2<sup>n</sup>)  
空间复杂度，使用了help[n]数组与样本量一样所以为O(N)

### 8.小结
在使用递归传递参数时，需要区分传递的是下标或是长度（比如，传递长度就是arr.length，传递下标就是arr.length-1），
需要作区分，所以统一在传递的时候都传入下标以作区分。  
归并排序每次merge的时候，都是左右两个区间比较，所以只要merge后，下次比较就是和另外的区间比较，所以快  
利用有序数据来加速merge    

### 9.小和问题
> 在一个数组中，每一个数左边比当前数晓得数累加起来，叫做这个数组的小和。求一个数组的小和。
>例子：  
>[1,3,4,2,5]  
>1左边比1小的数，没有；  
>3左边比3小的数，1  
>4左边比4小的数，1，3  
>2左边比2小的数，1  
>5左边比5小的数，1，3，4，2  
>所以小和为1+1+3+1+1+3+4+2=16

说明
> 通过归并排序的方式，每次merge的时候，都压榨左边比右边小的数*(R-idxr+1)的小和然后累加

### 10.逆序对问题
> 一个数组中，左边的数如果比右边的数大，则这两个数构成一个逆序对，请打印所有逆序对。

## 第二章

### 11.给定一个数组arr，和一个数num，请把小于等于num的数放在num的左边，大于num的数放右边
> 要求额外空间复杂度O(1),时间复杂度O(n)

`partition`

1 划定一个区域叫做小于等于num的区域，区域的区间就是x~L，初始化时x=-1

>  * 当x=-1时，表示-1到0的区间内的数小于等于num，没有
>  * 当x=0时，表示0到0区间的数小于等于num，有一个下标为0
>  * ...
>  * 当x=5时候，表示0到5区间的数小于num，有6个
>  * x始终保持在小于等于num区间的有边界下标上

2 始终cur往移动，当arr[cur]<=num时，swap(arr,++boundary,cur++)  


### 12.荷兰国旗
给定一个长度为n的数组arr，和一个数num，请把小于num的数放左边，等于num的数放中间，大于num的数放右边
> 额外空间复杂度O(1),时间复杂度O(n)
> 定义boundaryL=-1，boundaryR=arr.length  
>当arr[cur]<num时，swap(arr,++boundaryL,cur++)  
>当arr[cur]>num时，swap(arr,--boundaryR,cur)cur交换了一个没有比较的数到当前位置，所以需要再次比较，cur不用移动  
>当arr[cur]==num时，cur++
### 小结
1. L和R以及mid始终表示为左右边界下标，一般不会用这些变量直接做加减操作，如果要让当前下标移动，
需要定义一个比如i,j,idxL,idxR,cur,less,more,boundaryL,boundaryR等可以移动的下标变量

### 13.随机快排的细节和复杂度分析
利用荷兰国旗问题来改进快速排序  
时间复杂度O(N*logN),额外空间复杂度O(logN)  
分治思想，分左中右，三个区域，每个小于给定num的数放在左边，等于数值放在中间，大于的放在右边  
经典快排时间复杂度跟数据状况有关，利用随机数来打破数据状况起到加速的作用  
